function onload()

  table_missing = {}
  table_missing["White"] = false
  table_missing["Pink"] = false
  table_missing["Green"] = false
  table_missing["Yellow"] = false
  table_missing["Red"] = false
  table_missing["Blue"] = false


  table_zone = {}
  table_zone["White"] = 'e09210'
  table_zone["Pink"] = '7cb0f1'
  table_zone["Green"] = 'f1d518'
  table_zone["Red"] = '28be03'
  table_zone["Blue"] = '678bf3'
  table_zone["Yellow"] = '35b34d'

  table_token_moving = {}

  bool_4player = true

  -- Il vaut mieux eviter les objet global de maniere general, sauf si vraiment necessaire
  -- BOARDMAP_ZONE est appelé deux fois seulement, et se defini en une ligne
  -- c'est different des tableaux qui seront appelé plusieurs fois et se definissent en plusieur ligne
  -- BOARDMAP_ZONE = getObjectFromGUID('515a29')

  table_points = {}
  table_points['pink'] = 0
  table_points['red'] = 0
  table_points['green'] = 0
  table_points['blue'] = 0
  table_points['yellow'] = 0
  table_points['white'] = 0

  guild_position =
  {
    { --alchemistes
      {-33.15,  3,  9.70},
      { -33.15, 3,  6.96},
      { -33.15, 3,  6.13}
    },
    { -- knight
      {33.57, 3,  6.89},
      {33.57, 3,  9.59},
      {33.57, 3,  10.47}
    },
    { --merchant
      {-33.15,  3,  1.05},
      { -33.15, 3,  -1.39},
      { -33.15, 3,  -2.21}
    },
    { -- monk
      {33.57, 3,  -9.77},
      {33.57, 3,  -7.09},
      {33.57, 3,  -6.22}

    },
    { --noble
      {33.57, 3,  -1.45},
      {33.57, 3,  1.29},
      {33.57, 3,  2.15}
    },
    { -- farmer
      {-33.15,  3,  -7.02},
      {-33.15,  3,  -9.73},
      {-33.15,  3,  -10.61}
    }
  }

    local funcName = 'updateGuild'
    local func = function()
      for i=1,6 do
        local table_point = guildCount(i)
        updateGuildInfluence(table_point, i)
      end
    end
    self.setVar(funcName, func)
    self.createButton({
    click_function=funcName, function_owner=self, label = 'Update Guild Position',
    position={0,1.5,0}, rotation={0,180,0}, height=400, width=5000, font_size = 250,
    color = {0.89, 0.43, 0.51}, font_color = {0,0,0}
    })

    TABLE_REGION = {}
    TABLE_REGION["mountain_region"] = {{20.23, 1.16, 7.23}, {21.85, 1.16, 0.80}}
    TABLE_REGION["badlands_region"] = {{5.55, 1.36, 7.47}, {12.11, 1.16, 5.57}, {14.44, 1.36, -0.24}, {16.55, 1.16, -5.27}, {8.61, 1.16, 1.61}}
    TABLE_REGION["desert_region"] = {{-8.68, 1.16, -7.48}, {-4.67, 1.16, -2.73}, {9.53, 1.16, -6.42}, {-1.79, 1.36, -6.46}, {4.33, 1.36, -3.05}}
    TABLE_REGION["forest_region"] = {{-3.61, 1.36, 6.03}, {2.49, 1.36, 2.93}, {-12.35, 1.16, 6.99}}
    TABLE_REGION["island_region"] = {{-15.10, 1.16, 2.78}, {-11.13, 1.16, -1.23}, {-20.65, 1.16, -3.76}, {-16.00, 1.16, -6.94}}
    TABLE_REGION["sea_region"] = {{-19.90, 1.16, 6.25}, {-21.64, 1.16, 1.55}, {-8.16, 1.16, 2.25}}


    EPIC_VOYAGE = {{10.79, 1.16, 9.85}, {12.22, 1.16, 10.46}, {15.40, 1.16, 10.42}, {16.90, 1.16, 10.69}, {20.05, 1.16, 10.34}, {21.50, 1.16, 10.87}, {22.76, 1.16, 11.66}}

    MILITARY_SERVICE = {{-16.43, 1.16, -11.76}, {-13.46, 1.16, -11.38}, {-10.79, 1.16, -10.79}}

    EPOCH_MARKER = {{-11.72, 1.16, 9.35}, {-10.51, 1.16, 9.98}, {-8.82, 1.16, 10.13}, {-7.24, 1.16, 9.92}, {-5.92, 1.16, 9.29}}

    -- variable local
    local params = {
        click_function = "centralizedButton",
        function_owner = self,
        label          = "Next Epoch",
        position       = {11, 1.16, -2.33},
        rotation       = {0, 180, 0},
        width          = 750,
        height         = 300,
        font_size      = 125,
        color          = {0.97, 0.51, 0.22},
        font_color     = {0, 0, 0},
        tooltip        = "",
    }
    self.createButton(params)


    --Colors are always in this order : 1) pink 2) red 3)green 4)blue 5)yellow 6)white
    -- dans l'ideal on evite toujours de ce base sur un ordre pour ce genre de chose mais bon 
    -- si ca marche 

  -- on evite de donner des noms de variable qui peuvent etre utilise par programme comme les couleur
  -- ou table (tu le fais plus loin pour table)
  
  -- c'est tres malin de recuperer les couleur de cette facon
  -- pour eviter le probleme du gris 
  -- par contre, ca rajoute des tonne de boucle pour rien, mais je contournerais cela plus tard 

  -- ton code se repet, c'est le moment d'utiliser une boucle plutot que 
  -- creer plein de variable local pour rien

  COLOR ={'740bb1','1b257c','e74e7f','850665','3f489d','6c0762'}

  for key, values in pairs(COLOR) do
    -- on modifie direct la table COLOR
    COLOR[key] = getObjectFromGUID(values).getColorTint()
  end 

  --log(COLOR, 'general')
  --log(COLOR[2],'rouge')




end



-- function to launch guild update (numpad1)
function onScriptingButtonUp(index, color)
    if index == 1 then
      for i=1,6 do
        local table_point = guildCount(i)
        updateGuildInfluence(table_point, i)
      end
    end
end

-- helper to find object on top of position
function findObjectOnTop(pos, my_type, radius_y, radius_xz)

    -- Il vaut mieux utiliser le system mis en place par lua por les valeur par default
    -- je rajoute un type par default (car c'est 3 en general)

    local my_type = (my_type or 3)
    local radius_y = (radius_y or 1.5)
    local radius_xz = (radius_xz or radius_y)

    local objList = Physics.cast({
        origin=pos, direction={0,1,0}, type = my_type, debug=true,
        max_distance = 0, size={radius_xz, radius_y, radius_xz}
    })

    local refinedList = {}

    for key, value in ipairs(objList) do
      table.insert(refinedList, value.hit_object)
    end

    return refinedList
end



function getTitleType(value)
  local title_type = ""
  local temp_image = value.getCustomObject()
  local temp_url= ""
  if temp_image ~= nil then
    if (temp_image['image'] ~= nil) then
      if not value.is_face_down then
        temp_url = temp_image['image']
      else
        temp_url = temp_image['image_bottom']
      end
      if (temp_url == 'https://i.imgur.com/hk15lLU.jpg') then
        title_type = 'farm'
      elseif (temp_url == 'https://i.imgur.com/yt2yOIJ.jpg') then
        title_type = 'outpost'
      elseif (temp_url == 'https://i.imgur.com/UirRzRn.jpg') then
        title_type = 'town'
      end
    end
  end

  return title_type
end

function detectInfluence(title)

  local color = {}
  local position = title.getPosition()

  -- tu precise radius alors que cette variable n'existe pas
  -- si tu n'utilise pas toute les variable par defaut, 
  -- il faut preciser celle que on utilise plutot
  -- c'est assez mal faut en lua, dans d'autre language on preciserais pas nil et nil
  -- mais plutot le nom de variable utilisé...

  local table_object = findObjectOnTop(position, nil, nil, 0.4)

  for key,value in pairs(table_object) do
    -- print(value.getGUID())
    if (value.getName() == 'Influence') then
      color = value.getColorTint()
    end
  end

  -- Grey color to white
  if color[1] == 0.5 and color[2] == 0.5 and color[3] == 0.5 then
    color[1] = 1
    color[2] = 1
    color[3] = 1
   end

   return(color)

end

function detectInfluenceFromPosition(position, radius)

  local color = {}
  local table_object = findObjectOnTop({position[1],1.30 ,position[3]}, 3, radius, 0.4)

  --log(table_object)

  for key,value in pairs(table_object) do
    -- print(value.getGUID())
    if (value.getName() == 'Influence') then
      color = value.getColorTint()
    end
  end

  -- Grey color to white
  if color[1] == 0.5 and color[2] == 0.5 and color[3] == 0.5 then
    color[1] = 1
    color[2] = 1
    color[3] = 1
   end

   return(color)

end

function getInfluenceFromPosition(position, radius)

  local obj = nil
  local table_object = findObjectOnTop({position[1],1.30 ,position[3]}, 3, radius, 0.4)

  for key,value in pairs(table_object) do
    -- print(value.getGUID())
    if (value.getName() == 'Influence') then
      obj = value
      break
    end
  end

   return(obj)

end


function getGuildName(guild_number)

  local guild_name = ""
  if guild_number == 1 then guild_name = 'Alchemist'
  elseif guild_number == 2 then guild_name = 'Knight'
  elseif guild_number == 3 then guild_name = 'Merchant'
  elseif guild_number == 4 then guild_name = 'Monk'
  elseif guild_number == 5 then guild_name = 'Noble'
  elseif guild_number == 6 then guild_name = 'Farmer'
  end

  return(guild_name)
end

function guildCount(guild_number)

    -- get boardmap_zonesd

  local boardmap_zone = getObjectFromGUID('515a29')
  local temp_table = boardmap_zone.getObjects()

  local nb_player = 0

  -- create table for point and update number of players
  local table_point = {}
  if getObjectFromGUID('c2feb3') ~= nil then
    table_point['Green'] = 0
    nb_player = nb_player+1
  end
  if getObjectFromGUID('610c42') ~= nil then
    table_point['Pink'] = 0
    nb_player = nb_player+1
  end
  if getObjectFromGUID('401fca') ~= nil then
    table_point['White'] = 0
    nb_player = nb_player+1
  end
  if getObjectFromGUID('5df877') ~= nil then
    table_point['Red'] = 0
    nb_player = nb_player+1
  end
  if getObjectFromGUID('66e1c5') ~= nil then
    table_point['Blue'] = 0
    nb_player = nb_player+1
  end
  if getObjectFromGUID('0dda34') ~= nil then
    table_point['Yellow'] = 0
    nb_player = nb_player+1
  end

  if nb_player < 4 then
    bool_4player = false
  end


  local guild_name = getGuildName(guild_number)

  -- add 1 point for each  dice (6)
  for key,value in pairs(temp_table) do --actualcode
      if value.name == 'Custom_Dice' then
        if value.getDescription() ~= "" then
          if value.getValue() == guild_number then
             table_point[value.getDescription()] =  table_point[value.getDescription()] + 1
          end
        end
      end
  end

   -- add 3 point for each fief 6
  for key,value in pairs(temp_table) do --actualcode
      if value.getDescription() == 'fief'..guild_number then
        local color = detectInfluence(value)
        if next(color) ~= nil then
          for key_point,value_point in pairs(table_point) do
            if stringColorToRGB(key_point) == color then
              table_point[key_point] = table_point[key_point] + 3
            end
          end
        end
      end
  end


  for key,value in pairs(temp_table) do --actualcode
    local title_type =  getTitleType(value)
    if title_type ~= nil then
      local color = detectInfluence(value)
      if next(color) ~= nil then
        for key_point,value_point in pairs(table_point) do
          if stringColorToRGB(key_point) == color then
            if table_point[key_point] > 0 then
              if (guild_number == 1 or guild_number == 4) and title_type == 'outpost' then
                table_point[key_point] = table_point[key_point] + 1
              elseif (guild_number == 2 or guild_number == 6) and title_type == 'farm' then
                table_point[key_point] = table_point[key_point] + 1
              elseif (guild_number == 3 or guild_number == 5) and title_type == 'town' then
                table_point[key_point] = table_point[key_point] + 1
              end
            end
          end
        end
      end
    end


  end


  -- print point
  -- print(guild_name)
  -- for i,v in pairs(table_point) do
  --   print(i,':',v)
  -- end


  return(table_point)

end

function setInfluenceGuild(guild_number,guild_level, object_influence)

  object_influence.setPositionSmooth(guild_position[guild_number][guild_level], false, true)

end

function setInfluenceToPlayer(obj)

  -- get player zone
  local color = obj.getColorTint()
  local x_lag = 0
  local y_lag = 0

  if color[1] == 0.5 and color[2] == 0.5 and color[3] == 0.5 then
    zoneGuid = table_zone["White"]
    x_lag = -7.5
    y_lag = 6
  elseif  color == stringColorToRGB("Pink") then
    zoneGuid = table_zone["Pink"]
    x_lag = -7
    y_lag = 6
  elseif  color == stringColorToRGB("Green") then
    zoneGuid = table_zone["Green"]
    x_lag = -7
    y_lag = 6
  elseif  color == stringColorToRGB("Red") then
    zoneGuid = table_zone["Red"]
    x_lag = 7.5
    y_lag = -6
  elseif  color == stringColorToRGB("Blue") then
    zoneGuid = table_zone["Blue"]
    x_lag = 7
    y_lag = -6
  elseif  color == stringColorToRGB("Yellow") then
    zoneGuid = table_zone["Yellow"]
    x_lag = 7
    y_lag = -6
  end

  local pos1 = getObjectFromGUID(zoneGuid).getPosition()[1]+x_lag
  local pos2 = getObjectFromGUID(zoneGuid).getPosition()[2]+2
  local pos3 = getObjectFromGUID(zoneGuid).getPosition()[3]+y_lag

  obj.setPositionSmooth({pos1,pos2,pos3}, false, true)




end

function updateGuildLevel(table_point, guild_number, guild_level)

  -- if less than 4 player and guild level 3, no third position
  if (bool_4player == false) then
    if (guild_level == 3) then
      for key, value in pairs(table_point) do
        if (value ~= nil) then
          if (value > 0) then
            table_point[key] = 0
          end
        end
      end
    end
  end

  -- get actual guild position
  table_old = getGuildPosition(guild_number)
  -- get color to update
  temp_color = getFirstPlayerColor(table_point, table_old)
  -- for update guild level 1,2,3
  if guild_level > 0 then
  -- if there is a player in this position
    if temp_color ~= nil then
      -- if no influence in this position
      if (table_old[guild_level] == nil) then
        local token = getInfluenceFromZone(temp_color)
        if token ~= nil then
          setInfluenceGuild(guild_number,guild_level,token)
        else
          table_missing[temp_color] = true
          table_point[temp_color] = nil
          temp_color = getFirstPlayerColor(table_point, table_old)
          local bool_while = (temp_color ~= nil)
          while bool_while do
            token = getInfluenceFromZone(temp_color)
            if token ~= nil then
              setInfluenceGuild(guild_number,guild_level,token)
              bool_while = false
            else
              table_missing[temp_color] = true
              table_point[temp_color] = nil
              temp_color = getFirstPlayerColor(table_point, table_old)
              if temp_color == nil then
                bool_while = false
              end
            end
          end
        end
      else
        -- if  influence is correct
          if (stringColorToRGB(temp_color) == table_old[guild_level]) then
          -- if influence need update
          else
            local table_token = {
              getInfluenceFromGuild(guild_number,1),
              getInfluenceFromGuild(guild_number,2),
              getInfluenceFromGuild(guild_number,3)
            }

            -- case 1 <->2 or 2 <->3
            if guild_level < 3 then
              if (stringColorToRGB(temp_color) == table_old[guild_level+1]) then
                setInfluenceGuild(guild_number,guild_level,table_token[guild_level+1])
                setInfluenceGuild(guild_number,guild_level+1,table_token[guild_level])
              end
            end

            -- case first token in third position
            if guild_level == 1 then
              if (stringColorToRGB(temp_color) == table_old[3]) then
                setInfluenceGuild(guild_number,1,table_token[3])
                setInfluenceGuild(guild_number,3,table_token[2])
                setInfluenceGuild(guild_number,2,table_token[1])
              end
            end

            -- cases token not on guild
            if (stringColorToRGB(temp_color) ~= table_old[2] and stringColorToRGB(temp_color) ~= table_old[3]) then

              local token = getInfluenceFromZone(temp_color)
              if token == nil then
                table_missing[temp_color] = true
              else
              -- if third token on guild, get it back
                if (table_token[3] ~= nil) then
                  setInfluenceToPlayer(table_token[3])
                end

                if guild_level < 3 then
                  if (table_token[2] ~= nil) then
                    setInfluenceGuild(guild_number,3,table_token[2])
                  end
                end

                if guild_level == 1 then
                  setInfluenceGuild(guild_number,2,table_token[1])
                end

                setInfluenceGuild(guild_number,guild_level,token)


              end

            end
          end

      end
    end

    if (temp_color ~= nil) then
      table_point[temp_color] = nil
    end



  -- remove guild token with 0 point
  else
    for key, value in pairs(table_point) do
      if (value ==0) then
        for key_token, value_token in pairs(table_old) do
          if (stringColorToRGB(key) == value_token) then
            setInfluenceToPlayer(getInfluenceFromGuild(guild_number,key_token))
          end
        end
      end
    end
  end




end


function updateGuildInfluence(table_point, guild_number)


  table_old = nil
  temp_color = nil


  table_old = getGuildPosition(guild_number)
  local color_expect1 = stringColorToRGB(getFirstPlayerColor(table_point, table_old))

  updateGuildLevel(table_point, guild_number, 1)
  local color_expect2 = stringColorToRGB(getFirstPlayerColor(table_point, table_old))
  local color_expect3 = nil

  Wait.condition(
      function()
        updateGuildLevel(table_point, guild_number, 2)
        color_expect3 = stringColorToRGB(getFirstPlayerColor(table_point, table_old))
      end,
      function()
        return checkGuild(guild_number,1,color_expect1)
      end
    )


    Wait.condition(
        function() updateGuildLevel(table_point, guild_number, 3) end,
        function()
          return checkGuild(guild_number,2,color_expect2) and checkGuild(guild_number,1,color_expect1)
        end
      )




  Wait.condition(
      function()  updateGuildLevel(table_point, guild_number, 0) end,
      function() return checkGuild(guild_number,3,color_expect3) and checkGuild(guild_number,2,color_expect2) and checkGuild(guild_number,1,color_expect1) end,
      1,
      function() updateGuildLevel(table_point, guild_number, 0) end
    )



  Wait.frames(function () table_token_moving = {} end, 100)

end

function checkGuild(guild_number,guild_level, color_expect)
  local color_actual = detectInfluenceFromPosition(guild_position[guild_number][guild_level],0)
  local bool = false
  if color_expect == nil then
    bool = true
  else
    bool = color_expect == color_actual
  end
  return bool
end





function getInfluenceFromGuild(guild_number, guild_level)

  local obj = getInfluenceFromPosition(guild_position[guild_number][guild_level],0)
  return obj
end

function getInfluenceFromZone(color)

  local zoneGUID = table_zone[color]
  local token = nil

  local player_zone = getObjectFromGUID(zoneGUID)
  local temp_table = player_zone.getObjects()

  for key,value in pairs(temp_table) do --actualcode
    if (value.getName() == 'Influence') then
      token = value
      local bool = true
      if next(table_token_moving) ~= nil then
        for key_token,value_token in pairs(table_token_moving) do
          if token == value_token then
            bool = false
            token = nil
          end
        end
      end

      if bool then
        table.insert(table_token_moving, token)
        break
      end
    end
  end

  return(token)

end



function getGuildPosition(guild_number)

    local table_old = {}
    local color = detectInfluenceFromPosition(guild_position[guild_number][1],0)
    if next(color) ~= nil then
      table_old[1] = color
    end
    color = detectInfluenceFromPosition(guild_position[guild_number][2],0)
    if next(color) ~= nil then
      table_old[2] = color
    end
    color = detectInfluenceFromPosition(guild_position[guild_number][3],0)
    if next(color) ~= nil then
      table_old[3] = color
    end

    return(table_old)
end


function getFirstPlayerColor(table_point, table_old)

  local table_old = (table_old or nil)

  local color = nil
  local temp = 0
  for key, value in pairs(table_point) do
    if value > 0 then
      if value > temp then
        color = key
        temp = value
        -- log(temp)
      elseif value == temp then
        if (stringColorToRGB(key) == table_old[1]) then
          color = key
          temp = value
        elseif stringColorToRGB(color) ~= table_old[1] and stringColorToRGB(key) == table_old[2] then
          color = key
          temp = value
        elseif stringColorToRGB(color) ~= table_old[2] and stringColorToRGB(key) == table_old[3] then
          color = key
          temp = value
        end
      end
    end
  end

  return color
end

function onObjectDrop(player_color, dropped_object  )

  local bool_update_guild = false

  -- log('onObjectDrop')

  for key, value in pairs(table_missing) do
    -- if there is an influence missing
    if value then
      -- if the object frop is an influence
      if dropped_object.getName() == 'Influence' then
        local token_color = dropped_object.getColorTint()
        if token_color[1]==token_color[2] and token_color[1]==token_color[3] and token_color[1] == 0.5 then
          token_color = stringColorToRGB("White")
        end

        local temp_zone = getObjectFromGUID(table_zone[key])
        local temp_table = temp_zone.getObjects()

        -- check if influence if correct color
        if token_color ==stringColorToRGB(key) then

          -- check influence is drop in his the zone
          for key_zone, value_zone in pairs(temp_table) do
            if value_zone == dropped_object then
              broadcastToAll("influence have been place immediatly on guild\n")
              broadcastToAll(key, stringColorToRGB(key))
              bool_update_guild = true
              break
            end
          end
        end
      end
    end
  end

  if bool_update_guild then
    -- reset table_missing
    for key, value in pairs(table_missing) do
      table_missing[key] = false
    end

    for i=1,6 do
      table_point = guildCount(i)
      updateGuildInfluence(table_point, i)
    end
  end
end





----------------------------------------------------------------------
--UPDATE SCORE-----------------------------------------------------------------------
---------------UPDATE SCORE-----------------------------------------------------------------
---------------------------UPDATE SCORE----------------------------------------
----------------------------------------UPDATE SCORE---------------------------------------
----------------------------------------------------UPDATE SCORE--------------------------
-----------------------------------------------------------------UPDATE SCORE------------






--detecte le colortint des disques scores du palteau de jeu.
function detectDiscColor(position)

  local color_disc_list = {}
  local temp_object = findObjectOnTop({position[1],1.30 ,position[3]}, 3, 0.4)

  for k, value in pairs(temp_object) do

    local disc = value.getName()
    if value.getName() == 'Reeve/Disc' or 'Disc' then

      local color_disc = value.getColorTint()

      for x = 1,6 do
        if color_disc == COLOR[x] then
          table.insert(color_disc_list, COLOR[x])
        end
      end
    end
  end
  --log(color_disc_list,'color_disc_list 2eme')
  return color_disc_list
end


--Cette fonction est exactement la même que la tienne, mais j'ai supprimé le changement de couleur grey => white. Fais ce que tu veux.
function detectInfluenceFromLocation(position)

  local color = nil
  local table_object = findObjectOnTop({position[1],1.30 ,position[3]}, 3, radius, 0.4)
  --log(table_object)
  for key,value in pairs(table_object) do
    -- print(value.getGUID())
    if (value.getName() == 'Influence') then
      color = value.getColorTint()
    end
  end

  return(color)
end

-- Pour attribuer les couleurs à chaque table de score.
function loopInfColor(my_table, my_score, search_color)


  local temp_color = search_color
  local score = my_score

  for i = 1,6 do
    if temp_color == COLOR[i] then
      my_table[i] = my_table[i] + score
    end
  end
  return my_table
end

--Repèrer les landscapes, et déterminer le lieu le plus proche. Un cercle de lumière blanche s'allume 5 secondes autour du lieu retenu.

function detectNearestLocationLandscape()


  local color_inf_serf = {}
  local title_GUID = {}

  local boardmap_zone = getObjectFromGUID('515a29')
  local temp_table = boardmap_zone.getObjects()
  --log(temp_table,'temp_table')

  for key, temp_object in pairs(temp_table) do

    local object = temp_object.tag

    --log(object,'object')

    if object == 'Card' then
      if not temp_object.is_face_down then

        local table_distance = {}
        local table_title = {}
        local ldscp_pos = temp_object.getPosition()
        local ldscp_hit = findObjectOnTop(ldscp_pos, 2, 5)

        for key, object_hit in pairs(ldscp_hit) do

          local object_title = getTitleType(object_hit)
          local object_name = object_hit.getName()

          --log(object_title,'object_title')        

          if object_title == 'outpost' then
            local temp_distance = ldscp_pos:distance(object_hit.getPosition())
            local object_GUID = object_hit.getGUID()

            table.insert(table_distance, temp_distance)
            table.insert(table_title, object_GUID)

          elseif object_title == 'farm' then
            local temp_distance = ldscp_pos:distance(object_hit.getPosition())
            local object_GUID = object_hit.getGUID()

            table.insert(table_distance, temp_distance)
            table.insert(table_title, object_GUID)

          elseif object_title == 'town' then
            local temp_distance = ldscp_pos:distance(object_hit.getPosition())
            local object_GUID = object_hit.getGUID()

            table.insert(table_distance, temp_distance)
            table.insert(table_title, object_GUID)

          elseif object_name == 'fief' then

            local temp_distance = ldscp_pos:distance(object_hit.getPosition())
            local object_GUID = object_hit.getGUID()

            table.insert(table_distance, temp_distance)
            table.insert(table_title, object_GUID)
          end

          if object_name == 'Influence' then
            table.insert(color_inf_serf, object_hit.getColorTint())
          end
        end

        --Supprimer les lieu les plus éloignés
        local n = #table_distance
        while n > 1 do
          if table_distance[1] > table_distance[2] then
            table.remove(table_distance, 1)
            table.remove(table_title, 1)
          else table.remove(table_distance, 2)
            table.remove(table_title, 2)
          end
          n = #table_distance
        end
        --log(table_distance,'table_distance_2')
        --log(table_title,'table_title_2')

        --Mettre en surbrillance le lieu retenu
        local title_spoted = getObjectFromGUID(table_title[1])
        title_spoted.highlightOn({1,1,1}, 3)

        --Archiver le guid de la location
        table.insert(title_GUID, table_title[1])
      end
    end
  end

  return title_GUID, color_inf_serf

end


--Calcul du score d'époque de guilde.
function calculScoreGuild()

  local score_guild = {
    0,
    0,
    0,
    0,
    0,
    0
  }

  for key, type_guild in pairs(guild_position) do

    --Search the masters
    local score = 5
    score_guild = loopInfColor(score_guild, score, detectInfluenceFromLocation(type_guild[1]))

    --Search the journeymen
    local score = 3
    score_guild = loopInfColor(score_guild, score, detectInfluenceFromLocation(type_guild[2]))

    --Search the apprenties
    local score = 1
    score_guild = loopInfColor(score_guild, score, detectInfluenceFromLocation(type_guild[3]))
  end
  --log(score_guild,'final')
  return score_guild
end


-- Calcul du score d'époque des paysages vides ou pleins.
function calculScoreLandscape()

  local score_ldscp = {
    0,
    0,
    0,
    0,
    0,
    0
  }

  --Scan regions and determine pts, empty (2) or full (4).

  for key_region, value_region in pairs(TABLE_REGION) do
    for key_pos, value_pos in pairs(value_region) do

      local temp_hit = findObjectOnTop(value_pos, 2, 3.75)
      for key, value_hit in pairs(temp_hit) do

        local type = value_hit.tag
        if string.find(type, 'Card') then

          local ldscp_full = false
          local landscape_pos = value_hit.getPosition()
          local object_on_landscape = findObjectOnTop(landscape_pos, 3, 2.1)

          for key, value in pairs(object_on_landscape) do
            --log(ldscp_full,'1er')
            if value.getName() == 'Food' then
              ldscp_full = true
            elseif value.getName() == 'Archery Target' then
              ldscp_full = true
            elseif value.getName() == 'Shilling' then
              ldscp_full = true
            elseif value.getName() == 'Sulfur' then
              ldscp_full = true
            end
            --log(ldscp_full,'bonus ou non')
          end

          for key, value in pairs(object_on_landscape) do
            if value.getName() == 'Influence' then

              local score = 0
              if ldscp_full == true then
                 score = 4
               elseif ldscp_full == false then
                 score = 2
              end
              --log(score,'score')

    --Insert score on score_ldscp table.
              score_ldscp = loopInfColor(score_ldscp, score, value.getColorTint())
            end
          end
        end
      end
    end
  end
  --log(score_ldscp,'final')

  return score_ldscp
end


--Cette fonction est exactement la même que la tienne, mais j'ai supprimé le changement de couleur grey => white. Fais ce que tu veux.
function detectInfluenceFromLocation(position)

  local color = nil
  local table_object = findObjectOnTop({position[1],1.30 ,position[3]}, 3, radius, 0.4)
  --log(table_object)
  for key,value in pairs(table_object) do
    -- print(value.getGUID())
    if (value.getName() == 'Influence') then
      color = value.getColorTint()
    end
  end

  return color
end

-- Pour attribuer les couleurs à chaque table de score.
function loopInfColor(my_table, my_score, search_color)


  local temp_color = search_color
  local score = my_score

  for i = 1,6 do
    if temp_color == COLOR[i] then
      my_table[i] = my_table[i] + score
    end
  end
  return my_table
end

--Repèrer les landscapes, et déterminer le lieu le plus proche. Un cercle de lumière blanche s'allume 5 secondes autour du lieu retenu.

function detectNearestLocationLandscape()


  local color_inf_serf = {}
  local title_GUID = {}

  local boardmap_zone = getObjectFromGUID('515a29')
  local temp_table = boardmap_zone.getObjects()
  --log(temp_table,'temp_table')

  for key, temp_object in pairs(temp_table) do

    local object = temp_object.tag

    --log(object,'object')

    if object == 'Card' then
      if not temp_object.is_face_down then

        local table_distance = {}
        local table_title = {}
        local ldscp_pos = temp_object.getPosition()
        local ldscp_hit = findObjectOnTop(ldscp_pos, 2, 5)

        for key, object_hit in pairs(ldscp_hit) do

          local object_title = getTitleType(object_hit)
          local object_name = object_hit.getName()

          --log(object_title,'object_title')        

          if object_title == 'outpost' then
            local temp_distance = ldscp_pos:distance(object_hit.getPosition())
            local object_GUID = object_hit.getGUID()

            table.insert(table_distance, temp_distance)
            table.insert(table_title, object_GUID)

          elseif object_title == 'farm' then
            local temp_distance = ldscp_pos:distance(object_hit.getPosition())
            local object_GUID = object_hit.getGUID()

            table.insert(table_distance, temp_distance)
            table.insert(table_title, object_GUID)

          elseif object_title == 'town' then
            local temp_distance = ldscp_pos:distance(object_hit.getPosition())
            local object_GUID = object_hit.getGUID()

            table.insert(table_distance, temp_distance)
            table.insert(table_title, object_GUID)

          elseif object_name == 'fief' then

            local temp_distance = ldscp_pos:distance(object_hit.getPosition())
            local object_GUID = object_hit.getGUID()

            table.insert(table_distance, temp_distance)
            table.insert(table_title, object_GUID)
          end

          if object_name == 'Influence' then
            table.insert(color_inf_serf, object_hit.getColorTint())
          end
        end

        --Supprimer les lieu les plus éloignés
        local n = #table_distance
        while n > 1 do
          if table_distance[1] > table_distance[2] then
            table.remove(table_distance, 1)
            table.remove(table_title, 1)
          else table.remove(table_distance, 2)
            table.remove(table_title, 2)
          end
          n = #table_distance
        end
        --log(table_distance,'table_distance_2')
        --log(table_title,'table_title_2')

        --Mettre en surbrillance le lieu retenu
        local title_spoted = getObjectFromGUID(table_title[1])
        title_spoted.highlightOn({1,1,1}, 5)

        --Archiver le guid de la location
        table.insert(title_GUID, table_title[1])
      end
    end
  end

  return title_GUID, color_inf_serf

end


--Calcul du score final pour chaque location ruled. 1 pts for each or 3 pts for each fief.
function calculEachStandardLocationRuled()

  local each_standard_location_ruled = {
    0,
    0,
    0,
    0,
    0,
    0
  }


  for key_region, value_region in pairs(TABLE_REGION) do
    for key_pos, value_pos in pairs(value_region) do

      local color_ruler = detectInfluenceFromLocation(value_pos)

      if color_ruler ~= nil then

        local fief = false
        local hit_location_ruler = findObjectOnTop({value_pos[1],1.30 ,value_pos[3]}, 3, radius, 0.4)

        for k, value in pairs(hit_location_ruler) do

          if value.getName() == 'fief' then
            fief = true
            each_standard_location_ruled = loopInfColor(each_standard_location_ruled, 3, color_ruler)
          end
        end

        if fief == false then
          each_standard_location_ruled = loopInfColor(each_standard_location_ruled, 1, color_ruler)
        end
      end
    end
  end
  --log(each_standard_location_ruled,'each_standard_location_ruled')
  return each_standard_location_ruled

end

--Calcul du score final du voyage épique.
function calculScoreEpicVoyage()

  local score_epic_voyage = {
    0,
    0,
    0,
    0,
    0,
    0
  }

  for i = 1,7 do

    local color_disc_list = detectDiscColor(EPIC_VOYAGE[i])
    --log(EPIC_VOYAGE[i],'EPIC_VOYAGE[i]')
    --log(color_disc_list,'color_disc_list')
    if color_disc_list ~= nil then
      if i ~= 7 then
        for k,value in pairs(color_disc_list) do
          --log(value,'value1')
          local pts = i*2 + 1
          score_epic_voyage = loopInfColor(score_epic_voyage, pts, value)
        end

      elseif i == 7 then
        for k,value in pairs(color_disc_list) do
          --log(value, 'value17')
          local pts = 17
          score_epic_voyage = loopInfColor(score_epic_voyage, pts, value)
        end
      end
    end
 end
 --log(score_epic_voyage,'score_epic_voyage')
 return score_epic_voyage
end

--Fonction secondaire qui sert à déterminer le malus éventuel d'un joueur en fonction de l'époque.
function checkMilitaryServicePerformed(military_service)

  local military_service_performed = {
    true,
    true,
    true,
    true,
    true,
    true
  }

  local malus_service_false = 0

  if military_service == MILITARY_SERVICE[1] then
    malus_service_false = -3
  elseif military_service == MILITARY_SERVICE[2] then
    malus_service_false = -4
  elseif military_service == MILITARY_SERVICE[3] then
    malus_service_false = -5
  end

  local boardmap_zone = getObjectFromGUID('515a29')
  local temp_table = boardmap_zone.getObjects()

  for key,value in pairs(temp_table) do

    --Search if 'fief' on zoneboard and his ruler.

      if value.getName() == 'fief' then

        local temp_military_service_performed = false
        local pos_fief = value.getPosition()
        local color_ruler_fief = detectInfluenceFromLocation(pos_fief)

              --Search all markers in one MILITARY_SERVICE
        local color_disc_list = detectDiscColor(military_service)

        if color_disc_list ~= nil then
          for k,value in pairs(color_disc_list) do
            if value == color_ruler_fief then
              temp_military_service_performed = true
            end
          end

          --log(temp_military_service_performed,'temp_military_service_performed')
          if temp_military_service_performed == false then

            for x = 1,6 do
              if color_ruler_fief == COLOR[x] then
                military_service_performed[x] = false
              end
            end
          end
        end
      end
  end
  --log(military_service_performed)
  --log(malus_service_false,'malus_service_false')
  for i = 1,6 do
    if military_service_performed[i] == false then
      military_service_performed[i] = malus_service_false
    else military_service_performed[i] = 0
    end
  end
  --log(military_service_performed,'military_service_performed')
  return military_service_performed
end

-- divise un nombre par trois, arrondis à l'entier inférieur.
function doResultByThree(unit)

  local mod_unit = unit % 3
  local temp_unit = unit - mod_unit
  local total = temp_unit / 3

  return total
end


--Calcul du score pour la quantité de Shillings détenu dans la zone d'un joueurs (1 pt par tranche complète de 3 shillings)
function calculScoreShillingByZone(color_zone)
  --Shilling
  local nb_shilling = 0

  local zone = color_zone
  local hit_in_zone = zone.getObjects()

  for k, value in pairs(hit_in_zone) do
    if value.getName() == 'Shilling' then
      nb_shilling = nb_shilling + 1
    end
  end

  local color_score_shilling = doResultByThree(nb_shilling)
  --log(color_score_shilling)
  return color_score_shilling
end

--Déterminer le score final de shilling de chaque joueur
function calculScoreShilling()

  local pts = 0
  local score_shilling = {
    pts,
    pts,
    pts,
    pts,
    pts,
    pts
  }

  score_shilling[1] = calculScoreShillingByZone(getObjectFromGUID('7cb0f1'))
  score_shilling[2] = calculScoreShillingByZone(getObjectFromGUID('28be03'))
  score_shilling[3] = calculScoreShillingByZone(getObjectFromGUID('f1d518'))
  score_shilling[4] = calculScoreShillingByZone(getObjectFromGUID('678bf3'))
  score_shilling[5] = calculScoreShillingByZone(getObjectFromGUID('35b34d'))
  score_shilling[6] = calculScoreShillingByZone(getObjectFromGUID('e09210'))

  --log(score_shilling)
  return score_shilling

end


--Calcule un score temporaire par groupe de trois locations identiques
function tempScoreOneColorIdenticalLocation(my_table)

  local table = my_table

  --log(table,'tempScoreOneColorIdenticalLocation')
  local score_outpost = doResultByThree(table[1]) * 3
  local score_farm = doResultByThree(table[2]) * 3
  local score_town = doResultByThree(table[3]) * 3
  local score_fief = doResultByThree(table[4]) * 3

  local score = score_outpost + score_farm + score_town + score_fief

  --log(score,'tempScoreOneColorIdenticalLocation')
  return score
end

--Détermine le modulo d'un nombre divisé par trois, et détermine le nombre d'unités nécesaires pour arriver à 3
function doModuloByThree(my_table)

  local table = my_table
  --log(table,'doModuloByThree')
  local table_ajusted = {
    {0},
    {0},
    {0}
  }

  for i = 1,3 do
    local temp_mod = table[i] % 3
    table_ajusted[i] = 3 - temp_mod
  end

  --log(table_ajusted,'doModuloByThree')
  return table_ajusted
end

--Réparti les fiefs en fonction du nombre souhaité (1 ou 2)

function searchDivideFief(my_table, nb_fief_use)

  local table = my_table
  local table_ajusted = doModuloByThree(table)

  for i = 1,3 do
    if table[4] >= nb_fief_use and table_ajusted[i] == nb_fief_use then
      table[i] = table[i] + nb_fief_use
      table[4] = table[4] - nb_fief_use
    end
  end
  return table
end

--Répartition finale des fiefs

function divideFief(my_table)

  local table = my_table

  local table_1 = searchDivideFief(table, 1)
  --log(table_1,'table_1')
  local table_2 = searchDivideFief(table_1, 2)
  --log(table_2,'table_2')

  return table_2

end


--Calcule un score par groupe de trois locations identiques
function scoreOneColorIdenticalLocation(my_table)

  local table = my_table
  local final_table = divideFief(table)

  --log(table,'tempScoreOneColorIdenticalLocation')
  local score_outpost = doResultByThree(final_table[1]) * 3
  local score_farm = doResultByThree(final_table[2]) * 3
  local score_town = doResultByThree(final_table[3]) * 3
  local score_fief = doResultByThree(final_table[4]) * 3

  local score = score_outpost + score_farm + score_town + score_fief

  --log(score,'scoreOneColorIdenticalLocation')
  return score
end



-- Déterminer le nombre de locations_ruled de chaque type et pour chaque joueur, puis lancer le calcul du score pour chaque joueur.
function calculScoreAllColorsIdenticalLocation()

  local score_identical_location = {0}

  local loc = 0

  local table_loc_by_color = {
    {loc,loc,loc,loc}, --pink {outpost/farm/town/fief}
    {loc,loc,loc,loc}, --red {outpost/farm/town/fief}
    {loc,loc,loc,loc}, --green {outpost/farm/town/fief}
    {loc,loc,loc,loc}, --blue {outpost/farm/town/fief}
    {loc,loc,loc,loc}, --yellow {outpost/farm/town/fief}
    {loc,loc,loc,loc} --white {outpost/farm/town/fief}
  }


  for k_region, value_region in pairs(TABLE_REGION) do
    for k_pos, value_pos in pairs(value_region) do
      local color_ruler = detectInfluenceFromLocation(value_pos)
      if color_ruler ~= nil then
        for i = 1,6 do
          if color_ruler == COLOR[i] then
            local hit_pos = findObjectOnTop({value_pos[1],1.30 ,value_pos[3]}, 3, radius, 0.4)
            for k, value in pairs(hit_pos) do
              local hit_location = getTitleType(value)
              if hit_location == 'outpost' then
                table_loc_by_color[i][1] = table_loc_by_color[i][1] + 1
              elseif hit_location == 'farm' then
                table_loc_by_color[i][2] = table_loc_by_color[i][2] + 1
              elseif hit_location == 'town' then
                table_loc_by_color[i][3] = table_loc_by_color[i][3] + 1
              elseif value.getName() == 'fief' then
                table_loc_by_color[i][4] = table_loc_by_color[i][4] + 1
              end
            end
          end
        end
      end
    end
  end

  --log(table_loc_by_color,'table_loc_by_color')

  for i = 1,6 do
  score_identical_location[i] = scoreOneColorIdenticalLocation(table_loc_by_color[i])
  end
  --log(score_identical_location,'score_identical_location')
  return score_identical_location
end

--Ici, je détermine la fonction "addition" de ma métatable. j'ai essayé de faire l'addition de trois tables. J'ai pas réussi.
--Je ne sais pas si c'est parce que c'est impossible ou si c'est parce que je n'ai pas correctement config la fonction.
function addTwoScores(my_table1, my_table2)

  local total   = {}
  local t1 = my_table1
  local t2 = my_table2

  local mt = {}    -- Construction de la table qui servira de métatable.

  mt.__add = function(a, b)    -- Création de l'opération d'addition (__add)
    for i = 1,6 do
      total[i] = a[i] + b[i]
    end
  end

  setmetatable(t1, mt)    -- Association de la mt à score_region

  local function addition(a, b)    -- On ajoute un message d'erreur ... au cas ou!
    if (getmetatable(a) == nil) and (getmetatable(b) == nil) then
      error("Vous essayez d'additionner 2 tables sans métatable.")
    else
      local t = a + b
    end
  end

  addition(t1,t2)   -- On lance l'addition.

  return total
end



--Là, j'additionne les scores des régions, guildes et landscapes qui seront rappelés à chaque passage d'époque.
function calculScoreRegLdscpGuild()

  local score_reg_ldscp_guild = {}

  local score_region = calculScoreRegion()
  local score_ldscp = calculScoreLandscape()
  local score_guild = calculScoreGuild()

  local total_1 = addTwoScores(score_region, score_ldscp)

  score_reg_ldscp_guild = addTwoScores(total_1, score_guild)

  return score_reg_ldscp_guild
end

--Là, l'addition des scores qui renverra le score final qui sera ajouté après le score d'époque de l'âge 5.
function calculFinalScoring()

  local final_scoring = {}

  local score_epic_voyage = calculScoreEpicVoyage()
  local score_shilling = calculScoreShilling()
  local score_ident_loc = calculScoreAllColorsIdenticalLocation()
  local score_each_loc_ruled = calculEachStandardLocationRuled()

  local total_1 = addTwoScores(score_epic_voyage, score_shilling)
  local large_empire = addTwoScores(score_each_loc_ruled, score_ident_loc)

  final_scoring = addTwoScores(total_1, large_empire)

  return final_scoring
end

--La fonction qui bouge le marqueur époque vers son époque suivante. Cette fonction renvoie aussi la nouvelle position du marqueur.
function moveEpochMarker()

  local new_pos = {}

  for i = 1,5 do
    local hit_value = findObjectOnTop(EPOCH_MARKER[i], 3, radius, 0.4)
    for k,value in pairs(hit_value) do
      if value.getName() == 'Epoch Marker' then
        if i ~= 5 then
          local obj_marker = getObjectFromGUID('3976bc')
          obj_marker.setPositionSmooth(EPOCH_MARKER[i+1], false, false)
          new_pos = EPOCH_MARKER[i+1]
        end
      end
    end
  end
  return new_pos
end

--Determine l'époque à prendre en compte pour calculer le malus éventuel des services militaires
function calculScoreMilitaryService(epoch_marker_pos)

  local total_score_milit = {}
  local pos = epoch_marker_pos

  if pos == EPOCH_MARKER[2] then
    total_score_milit = checkMilitaryServicePerformed(MILITARY_SERVICE[1])
  end

  if pos == EPOCH_MARKER[4] then
    local total_1 = checkMilitaryServicePerformed(MILITARY_SERVICE[1])
    local total_2 = checkMilitaryServicePerformed(MILITARY_SERVICE[2])
    total_score_milit = addTwoScores(total_1, total_2)
  end

  if pos == EPOCH_MARKER[5] then
    local total_1 = checkMilitaryServicePerformed(MILITARY_SERVICE[1])
    local total_2 = checkMilitaryServicePerformed(MILITARY_SERVICE[2])
    local total_3 = addTwoScores(total_1, total_2)
    local total_4 = checkMilitaryServicePerformed(MILITARY_SERVICE[3])
    total_score_milit = addTwoScores(total_3, total_4)
  end

  return total_score_milit
end

--Renvoi le score époque définitif, avec l'éventuel calcul du malus adéquat, si besoin est.
function scoreEpoch(new_pos_marker)

  local score_epoch = {}
  local new_pos = new_pos_marker

  if new_pos == EPOCH_MARKER[2] then
    local score_milit = calculScoreMilitaryService(EPOCH_MARKER[2])
    score_epoch = addTwoScores(score_milit, calculScoreRegLdscpGuild())
  elseif new_pos == EPOCH_MARKER[3] then
    score_epoch = calculScoreRegLdscpGuild()
  elseif new_pos == EPOCH_MARKER[4] then
    local score_milit = calculScoreMilitaryService(EPOCH_MARKER[4])
    score_epoch = addTwoScores(score_milit, calculScoreRegLdscpGuild())
  elseif new_pos == EPOCH_MARKER[5] then
    local score_milit = calculScoreMilitaryService(EPOCH_MARKER[5])
    score_epoch = addTwoScores(score_milit, calculScoreRegLdscpGuild())
  end

  return score_epoch
end

--Définir la fonction qui imprimera les scores sur le chat
function printScore(my_table)

  local color = {
    'pink',
    'red',
    'green',
    'blue',
    'yellow',
    'white',
  }

  local affichage = ''
  for i = 6, 1, -1 do
    affichage = color[i].." = "..my_table[i].."\n"..affichage
    end
  printToAll(affichage)
end

--Déterminer la fonction du bouton centralisé :

            --Bouger le marqueur
            --Calculer le score Epoch adéquat
            --Calculer le score final si nous sommes en fin de partie.

                     --(Attention pour bouger le pion score du bord du plateau, il n'y a qu'un score à prendre en compte)
                     --(car l'addition du score d'époque et du score final est déjà faite.)
                     --(J'ai volontairement séparé les affichages des deux scores car )
                            --Ils sont séparés dans les règles.)
                            --Ce sera plus facile aux joueurs de contrôler les scores calculés.)

            -- J'aimerai aussi activer les fonctions de réapprovisionnement lorsque nécessaire aux bonnes époques.
              --J'arrive pas à le faire, si tu peux m'aider stp.

            --Afficher un petit message sur la fenêtre principale du jouer, mais ça s'efface de suite. Y a pas une fonction qui permet de garder
              --l'affichage genre une minute? Du coup, je ne suis pas sûr que mon choix de couleur soit optimal. Je veux du voyant sans être flash.

function centralizedButton()

  local new_pos_marker = moveEpochMarker()
  local score = {}

  if new_pos_marker ~= EPOCH_MARKER[5] then
    score = scoreEpoch(new_pos_marker)
    printToAll('Score epoch')
    printScore(score)

  elseif new_pos_marker == EPOCH_MARKER[5] then

    local score_epoch = scoreEpoch(new_pos_marker)
    printToAll('Score epoch')
    printScore(score_epoch)

    local final_scoring = calculFinalScoring()
    printToAll('Final scoring')
    printScore(final_scoring)

    score = addTwoScores(score_epoch, final_scoring)

    local msg = "Game over. Don't forget to add your royal writ with king's seal !!  Thanks"
    local rgb = {r=0.14, g=0.18, b=0.26}
    broadcastToAll(msg, rgb)

  end

    --if new_pos_marker == EPOCH_MARKER[2] then
    --  Global.click_Button(1)
    --end

    --if new_pos_marker == EPOCH_MARKER[3] then
    --  Global.click_Button(2)
    --end

    --if new_pos_marker == EPOCH_MARKER[4] then
    --  Global.click_Button(3)
    --end

    --if new_pos_marker == EPOCH_MARKER[3] then
    --  Global.click_Button(4)
    --end

end
